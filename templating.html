<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Expectations by jaycfields</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="javascripts/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1 class="header">Expectations</h1>
        <p class="header">a minimalist's unit testing framework</p>

        <ul>
          <li><a class="buttons" href="index.html">Home</a></li>
          <li><a class="buttons" href="installing.html">Installing</a></li>
          <li><a class="buttons" href="introduction.html">Introduction</a></li>
          <li><a class="buttons" href="advanced.html">Advanced</a></li>
          <li><a class="buttons" href="collections.html">Collections</a></li>
          <li><a class="buttons" href="double-nan.html">Double/NaN</a></li>
          <li><a class="buttons" href="templating.html">Templating</a></li>
          <li><a class="buttons" href="expect-let.html">Expect-Let</a></li>
          <li><a class="buttons" href="odds-ends.html">Odds & Ends</a></li>
          <li><a class="buttons" href="in-context.html">Around Each</a></li>
          <li><a class="buttons" href="before-run-hook.html">Before Each</a></li>
          <li><a class="buttons" href="state-warnings.html">State Warnings</a></li>
          <li><a class="buttons" href="freeze-time.html">Redef State</a></li>
          <li><a class="buttons" href="interactions.html">Interactions</a></li>
          <li><a class="buttons" href="interaction-args.html">Interaction Args</a></li>
          <li><a class="buttons" href="interaction-args.html">Java Interactions</a></li>
          <li><a class="buttons" href="freeze-time.html">Freeze Time</a></li>
          <li><a class="buttons" href="env-tweaks.html">ENV Tweaks</a></li>
          <li><a class="buttons github" href="https://github.com/jaycfields/expectations">View On GitHub</a></li>
        </ul>

        <p class="header">This project is maintained by <a class="header name" href="https://github.com/jaycfields">jaycfields</a></p>


      </header>
      <section>
        <h1>
<a name="expectations" class="anchor" href="#expectations"><span class="octicon octicon-link"></span></a>expectations</h1>

<blockquote>
<p>adding signal, removing noise</p>
</blockquote>

<h2>
<a name="templating" class="anchor" href="#templating"><span class="octicon octicon-link"></span></a>Templating with Given</h2>


<a href="https://github.com/jaycfields/expectations">expectations</a> obviously has a bias towards <a href="http://blog.jayfields.com/2007/06/testing-one-assertion-per-test.html">one assertion per test</a>; however, there are times that verifying several things at the same time does make sense. For example, if you want to verify a few different properties of the same Java object it probably makes sense to make multiple assertions on the same instance.<br />
<br />
One of the biggest problems with multiple assertions per test is when your test follows this pattern:<br />
<ol>
<li>create some state</li>
<li>verify a bit about the state</li>
<li>alter the state</li>
<li>verify more about the state</li>
</ol>
Part of the problem is that the assertions that occurred before the altering of the state may or may not be relevant after the alteration. Additionally, if any of the assertions fail you have to stop running the entire test - thus some of your assertions will not be run (and you'll be lacking some information).<br />
<br />
expectations takes an alternate route - embracing the idea of multiple assertions by providing a specific syntax that allows multiple verifications and the least amount of duplication.<br />
<br />
The following example shows how you can test multiple properties of a Java object using the 'given' syntax.<br />
<pre>(given (java.util.ArrayList.)
       (expect
         .size 0
         .isEmpty true))

jfields$ lein expectations
Ran 2 tests containing 2 assertions in 4 msecs
0 failures, 0 errors.</pre>
The syntax is simple enough: (given an-object (expect method return-value [method return-value])) <br />
note: [method return-value] may be repeated any number of times.<br />
<br />
This syntax allows us to expect return-values from as many methods as we care to verify, but encourages us not to change any state between our various assertions. This syntax also allows us to to run each assertion regardless of the outcome of any previous assertion.<br />
<br />
Obviously you could call methods that change the internal state of the object and at that point you're on your own. I definitely wouldn't recommend testing that way. However, as long as you call methods that don't change any state 'given' can help you write succinct tests that verify as many aspects of an object as you need to test.<br />
<br />
As usual, I'll show the output for tests that fail using this syntax.<br />
<pre>(given (java.util.ArrayList.)
       (expect
         .size 1
         .isEmpty false))

jfields$ lein expectations
failure in (core.clj:4) : sample.test.core
           (expect 1 (.size (java.util.ArrayList.)))
           expected: 1
                was: 0
failure in (core.clj:4) : sample.test.core
           (expect false (.isEmpty (java.util.ArrayList.)))
           expected: false
                was: true</pre>
This specific syntax was created for testing Java objects, but an interesting side effect is that it actually works on any value and you can substitute method calls with any function. For example, you can test a vector or a map using the examples below as a template.<br />
<pre>(given [1 2 3]
       (expect
         first 1
         last 3))

(given {:a 2 :b 4}
       (expect
         :a 2
         :b 4))

jfields$ lein expectations
Ran 4 tests containing 4 assertions in 8 msecs
0 failures, 0 errors.</pre>
And, of course, the failures.<br />
<pre>(given [1 2 3]
       (expect
         first 2
         last 1))

(given {:a 2 :b 4}
       (expect
         :a 1
         :b 1))

jfields$ lein expectations
failure in (core.clj:4) : sample.test.core
           (expect 2 (first [1 2 3]))
           expected: 2
                was: 1
failure in (core.clj:4) : sample.test.core
           (expect 1 (last [1 2 3]))
           expected: 1
                was: 3
failure in (core.clj:9) : sample.test.core
           (expect 1 (:a {:a 2, :b 4}))
           expected: 1
                was: 2
failure in (core.clj:9) : sample.test.core
           (expect 1 (:b {:a 2, :b 4}))
           expected: 1
                was: 4
Ran 4 tests containing 4 assertions in 14 msecs
4 failures, 0 errors.</pre>
When you want to call methods on a Java object or call functions with the same instance over and over the previous given syntax is really the simplest solution. However, there are times where you want something more flexible.<br />
<br />
expectations also has a 'given' syntax that allows you to specify a template - thus reducing code duplication. The following example shows a test that verifies + with various arguments.<br />
<pre>(given [x y] (expect 10 (+ x y))
       4 6
       6 4
       12 -2)

jfields$ lein expectations
Ran 3 tests containing 3 assertions in 5 msecs
0 failures, 0 errors.</pre>
The syntax for this flavor of given is: (given bindings template-form values-to-be-bound). The template form can be anything you need - just remember to put the expect in there.<br />
<br />
Here's another example where we combine given with in to test a few different things. This example shows both the successful and failing versions.<br />
<pre>;; successful
(given [x y] (expect x (in y))
       :a #{:a :b}
       {:a :b} {:a :b :c :d})

;; failure
(given [x y] (expect x (in y))
       :c #{:a :b}
       {:a :d} {:a :b :c :d})

lein expectations
failure in (core.clj:8) : sample.test.core
           (expect :c (in #{:a :b}))
           key :c not found in #{:a :b}
failure in (core.clj:8) : sample.test.core
           (expect {:a :d} (in {:a :b, :c :d}))
           expected: {:a :d}
                 in: {:a :b, :c :d}
           :a expected: :d
                   was: :b
Ran 4 tests containing 4 assertions in 13 msecs
2 failures, 0 errors.</pre>
That's basically it for 'given' syntax within expectations. There are times that I use all of the various versions of given; however, there seems to be a connection with using given and interacting with Java objects. If you don't find yourself using Java objects very often then you probably wont have a strong need for given.

      </section>
      <footer>
        <p><small>Hosted on <a href="https://pages.github.com">GitHub Pages</a> using the Dinky theme</small></p>
      </footer>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

  </body>
</html>
