<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Expectations by jaycfields</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="javascripts/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1 class="header">Expectations</h1>
        <p class="header">a minimalist's unit testing framework</p>

        <ul>
          <li><a class="buttons" href="index.html">Home</a></li>
          <li><a class="buttons" href="installing.html">Installing</a></li>
          <li><a class="buttons" href="introduction.html">Introduction</a></li>
          <li><a class="buttons" href="advanced.html">Advanced</a></li>
          <li><a class="buttons" href="collections.html">Collections</a></li>
          <li><a class="buttons" href="double-nan.html">Double/NaN</a></li>
          <li><a class="buttons" href="templating.html">Templating</a></li>
          <li><a class="buttons" href="expect-let.html">Expect-Let</a></li>
          <li><a class="buttons" href="odds-ends.html">Odds & Ends</a></li>
          <li><a class="buttons" href="in-context.html">Around Each</a></li>
          <li><a class="buttons" href="before-run-hook.html">Before Each</a></li>
          <li><a class="buttons" href="state-warnings.html">State Warnings</a></li>
          <li><a class="buttons" href="freeze-time.html">Redef State</a></li>
          <li><a class="buttons" href="interactions.html">Interactions</a></li>
          <li><a class="buttons" href="interaction-args.html">Interaction Args</a></li>
          <li><a class="buttons" href="interaction-args.html">Java Interactions</a></li>
          <li><a class="buttons" href="freeze-time.html">Freeze Time</a></li>
          <li><a class="buttons" href="env-tweaks.html">ENV Tweaks</a></li>
          <li><a class="buttons github" href="https://github.com/jaycfields/expectations">View On GitHub</a></li>
        </ul>

        <p class="header">This project is maintained by <a class="header name" href="https://github.com/jaycfields">jaycfields</a></p>


      </header>
      <section>
        <h1>
<a name="expectations" class="anchor" href="#expectations"><span class="octicon octicon-link"></span></a>expectations</h1>

<blockquote>
<p>adding signal, removing noise</p>
</blockquote>

<h2>
<a name="templating" class="anchor" href="#templating"><span class="octicon octicon-link"></span></a>Templating with Given</h2>


<a href="https://github.com/jaycfields/expectations">expectations</a> obviously has a bias towards <a href="http://blog.jayfields.com/2007/06/testing-one-assertion-per-test.html">one assertion per test</a>; however, there are times that verifying several things at the same time does make sense. For example, if you want to verify a few different properties of the same Java object it probably makes sense to make multiple assertions on the same instance.<br />
<br />
One of the biggest problems with multiple assertions per test is when your test follows this pattern:<br />
<ol>
<li>create some state</li>
<li>verify a bit about the state</li>
<li>alter the state</li>
<li>verify more about the state</li>
</ol>
Part of the problem is that the assertions that occurred before the altering of the state may or may not be relevant after the alteration. Additionally, if any of the assertions fail you have to stop running the entire test - thus some of your assertions will not be run (and you'll be lacking some information).<br />
<br />
expectations takes an alternate route - embracing the idea of multiple assertions by providing a specific syntax that allows multiple verifications and the least amount of duplication.
The 'given' macro allows you to specify a template - thus reducing code duplication. The following example shows a test that verifies + with various arguments.<br />
<pre>(given [x y] (expect 10 (+ x y))
       4 6
       6 4
       12 -2)

jfields$ lein expectations
Ran 3 tests containing 3 assertions in 5 msecs
0 failures, 0 errors.</pre>
The syntax for this flavor of given is: (given bindings template-form values-to-be-bound). The template form can be anything you need - just remember to put the expect in there.<br />
<br />
Here's another example where we combine given with in to test a few different things. This example shows both the successful and failing versions.<br />
<pre>;; successful
(given [x y] (expect x (in y))
       :a #{:a :b}
       {:a :b} {:a :b :c :d})

;; failure
(given [x y] (expect x (in y))
       :c #{:a :b}
       {:a :d} {:a :b :c :d})

lein expectations
failure in (core.clj:8) : sample.test.core
           (expect :c (in #{:a :b}))
           key :c not found in #{:a :b}
failure in (core.clj:8) : sample.test.core
           (expect {:a :d} (in {:a :b, :c :d}))
           expected: {:a :d}
                 in: {:a :b, :c :d}
           :a expected: :d
                   was: :b
Ran 4 tests containing 4 assertions in 13 msecs
2 failures, 0 errors.</pre>
That's basically it for 'given' syntax within expectations. It's nothing more than a simple tempate, allowing you to reduce the amount of boiler-plate code your similar tests will need.

      </section>
      <footer>
        <p><small>Hosted on <a href="https://pages.github.com">GitHub Pages</a> using the Dinky theme</small></p>
      </footer>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

  </body>
</html>
