<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Expectations by jaycfields</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="javascripts/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1 class="header">Expectations</h1>
        <p class="header">a minimalist's unit testing framework</p>

        <ul>
          <li><a class="buttons" href="index.html">Home</a></li>
          <li><a class="buttons" href="installing.html">Installing</a></li>
          <li><a class="buttons" href="introduction.html">Introduction</a></li>
          <li><a class="buttons" href="advanced.html">Advanced</a></li>
          <li><a class="buttons" href="collections.html">Collections</a></li>
          <li><a class="buttons" href="templating.html">Templating</a></li>
          <li><a class="buttons" href="expect-let.html">Expect-Let</a></li>
          <li><a class="buttons" href="odds-ends.html">Odds & Ends</a></li>
          <li><a class="buttons" href="in-context.html">Around Each</a></li>
          <li><a class="buttons" href="before-run-hook.html">Before Suite</a></li>
          <li><a class="buttons" href="state-warnings.html">State Warnings</a></li>
          <li><a class="buttons" href="redef-state.html">Redef State</a></li>
          <li><a class="buttons" href="interactions.html">Interactions</a></li>
          <li><a class="buttons" href="interaction-args.html">Interaction Args</a></li>
          <li><a class="buttons" href="java-interactions.html">Java Interaction</a></li>
          <li><a class="buttons" href="freeze-time.html">Freeze Time</a></li>
          <li><a class="buttons" href="env-tweaks.html">ENV Tweaks</a></li>
          <li><a class="buttons" href="emacs-tweaks.html">emacs Tweaks</a></li>
          <li><a class="buttons github" href="https://github.com/jaycfields/expectations">View On GitHub</a></li>
        </ul>

        <p class="header">This project is maintained by <a class="header name" href="https://github.com/jaycfields">jaycfields</a></p>


      </header>
      <section>
        <h1>
<a name="expectations" class="anchor" href="#expectations"><span class="octicon octicon-link"></span></a>expectations</h1>

<blockquote>
<p>adding signal, removing noise</p>
</blockquote>

<h2>
<a name="templating" class="anchor" href="#templating"><span class="octicon octicon-link"></span></a>Templating with Given</h2>


<a href="https://github.com/jaycfields/expectations">expectations</a> obviously has a bias towards <a href="http://blog.jayfields.com/2007/06/testing-one-assertion-per-test.html">one assertion per test</a>; however, there are times that verifying several things at the same time does make sense. For example, if you want to verify a few different properties of the same Java object it probably makes sense to make multiple assertions on the same instance.<br />
<br />
One of the biggest problems with multiple assertions per test is when your test follows this pattern:<br />
<ol>
<li>create some state</li>
<li>verify a bit about the state</li>
<li>alter the state</li>
<li>verify more about the state</li>
</ol>
Part of the problem is that the assertions that occurred before the altering of the state may or may not be relevant after the alteration. Additionally, if any of the assertions fail you have to stop running the entire test - thus some of your assertions will not be run (and you'll be lacking some information).<br />
<br />
expectations takes an alternate route - embracing the idea of multiple assertions by providing a specific syntax that allows multiple verifications and the least amount of duplication.
<br>
expectations has always given you the ability to test against an arbitrary fn, similar to the example below.
<br><br>
<pre>(expect nil? nil)</pre>

The ability to specify any fn is powerful, but it doesn't always give you the most descriptive failure messages.
In expectations 2.0 we introduce the 'more, 'more->, & 'more-of macros, which are designed to allow you to expect
more of your actual values.
<br>
Below is a simple example of using the more macro.
<br><br>
<pre>(expect (more vector? not-empty) [1 2 3])</pre>
As you can see from the above example, we're simply expecting that the actual value '[1 2 3] is both a 'vector? and 'not-empty.
The 'more macro is great when you want to test a few 1 arg fns; however, I expect you'll more often find yourself reaching for
'more-> and 'more-of.
<br>
The 'more-> macro is used for threading the actual value and comparing the result to an expected value. Below is a simple
example of using 'more to pull values out of a vector and test their equality.
<br><br>
<pre>(expect (more-> 1 first
                3 last)
  [1 2 3])</pre>

The 'more-> macro threads using -> (thread-first), so you're able to put any form you'd like in the actual transformation.

    (expect (more-> 2 (-> first (+ 1))
                    3 last)
      [1 2 3])
Finally, 'more-> can be very helpful for testing various kv pairs within a map, or various Java fields.

    (expect (more-> 0 .size
                    true .isEmpty)
       (java.util.ArrayList.))

    (expect (more-> 2 :a
                    4 :b)
       {:a 2 :b 4})
Threading is great work, if you can get it. For the times when you need to name your actual value, 'more-of should do the trick. The following example demonstrates how to name your actual value and then specify a few expectations.

    (expect (more-of x
                     vector? x
                     1 (first x))
      [1 2 3])
If you've ever found yourself wishing you had destructuring in clojure.test/are or expectations/given, you're not alone. The good news is, 'more-of supports any destructuring you want to give it.

    (expect (more-of [x :as all]
                     vector? all
                     1 x)
      [1 2 3])
1.3 combining side-effects and more-of

It's fairly common to expect some behavior where you know the exact values for some of the args, and you have something more general in mind for the additional args. By combining 'side-effects and 'more-of you can easily great a call into it's args and verify as many as you care to verify.

    (expect (more-of [path data action {:keys [a c]}]
                     String path
                     #"some da" data
                     keyword? action
                     :b a
                     :d c)
      (in (side-effects [spit]
            (spit "/tmp/hello-world" "some data" :append {:a :b :c :d :e :f}))))
The above test is a bit much to swallow at first glance; however, it's actually very straightforward once you've gotten used to the 'more-of syntax. In the above example the 'spit fn is called with the args "/tmp/hello-world", "some data" :append {:a :b :c :d :e :f}. Using 'more-of, we destructure those args, and expect them individually. The path arg is expected to be of type String. The data arg is expected to be a string that matches the regex "some da". The action is expected to be a 'keyword?. Finally, the options map is destructured to it's :a and :c values, and equality expected.

1.4 from-each

It's common to expect something from a list of actual values. Traditionally 'given was used to generate many tests from one form. Unfortunately 'given suffered from many issues: no ability to destructure values, failure line numbers were almost completely useless, and little visibility into what the problem was when a failure did occur.

In expectations 2.0 'from-each was introduced to provide a more powerful syntax as well as more helpful failure messages.

Below you can see a very simple expectation that verifies each of the elements of a vector is a String.

    (expect String
      (from-each [letter ["a" "b" "c"]]
        letter))
Hopefully the syntax of 'from-each feels very familiar, it's been written to handle the same options as 'for and 'doseq - :let and :when.

    (expect odd? (from-each [num [1 2 3]
                             :when (not= num 2)]
                   num))

    (expect odd? (from-each [num [1 2 3]
                             :when (not= num 2)
                             :let [numinc1 (inc num)]]
                   (inc numinc1)))
While 'from-each is helpful in creating concise tests, I actually find it's most value when a test fails. If you take the above test and remove the :when, you would have the test below.

    (expect odd? (from-each [num [1 2 3]
                             :let [numinc1 (inc num)]]
                   (inc numinc1)))
The above test would definitely fail, but it's not immediately obvious what the issue is. However, the failure message should quickly lead you to the underlying issue.

    failure in (success_examples.clj:206) : success.success-examples
    (expect
     odd?
     (from-each [num [1 2 3] :let [numinc1 (inc num)]] (inc numinc1)))

               the list: (3 4 5)

    (expect odd? (inc numinc1))

                 locals num: 2
                        numinc1: 3
               4 is not odd?

As you can see above, when 'from-each fails it will give you values of every var defined within the 'from-each bindings. As a result, it's fairly easy to find the combination of vars that led to a failing test.




The 'given' macro allows you to specify a template - thus reducing code duplication. The following example shows a test that verifies + with various arguments.<br />
<pre>(given [x y] (expect 10 (+ x y))
       4 6
       6 4
       12 -2)

jfields$ lein expectations
Ran 3 tests containing 3 assertions in 5 msecs
0 failures, 0 errors.</pre>
The syntax for this flavor of given is: (given bindings template-form values-to-be-bound). The template form can be anything you need - just remember to put the expect in there.<br />
<br />
Here's another example where we combine given with in to test a few different things. This example shows both the successful and failing versions.<br />
<pre>;; successful
(given [x y] (expect x (in y))
       :a #{:a :b}
       {:a :b} {:a :b :c :d})

;; failure
(given [x y] (expect x (in y))
       :c #{:a :b}
       {:a :d} {:a :b :c :d})

lein expectations
failure in (core.clj:8) : sample.test.core
           (expect :c (in #{:a :b}))
           key :c not found in #{:a :b}
failure in (core.clj:8) : sample.test.core
           (expect {:a :d} (in {:a :b, :c :d}))
           expected: {:a :d}
                 in: {:a :b, :c :d}
           :a expected: :d
                   was: :b
Ran 4 tests containing 4 assertions in 13 msecs
2 failures, 0 errors.</pre>
That's basically it for 'given' syntax within expectations. It's nothing more than a simple tempate, allowing you to reduce the amount of boiler-plate code your similar tests will need.

      </section>
      <footer>
        <p><small>Hosted on <a href="https://pages.github.com">GitHub Pages</a> using the Dinky theme</small></p>
      </footer>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

  </body>
</html>
